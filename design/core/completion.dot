digraph G {
    // whether to use a link or not
    {
        // starting values
        {L_start [label="use links for %?"]}

        // ending values
        {L_use [label="affects %"; shape=box]}
        {L_nouse [label="no effect"; shape=box]}
        {L_nt_invalid [label="invalid"; shape=box]}

        {L_links [label="has links"]}
        {L_nolinks [label="no links"]}

        {L_nt [label="node type?"; shape=triangle]}
        {L_nt_req [label="REQ"]}
        {L_nt_other [label="other"]}

        L_start -> L_nt;
        L_nt -> L_nt_req -> L_nt_invalid;
        L_nt -> L_nt_other;
            L_nt_other -> L_links;
            L_nt_other -> L_nolinks;

        // node type is other, find calulation

        // has links
        L_links -> L_use [label="calc %"];

        // no links
        L_nolinks -> {L_nl_a [label="parts"]} -> L_nouse;
        L_nolinks -> {L_nl_b [label="no parts"]} [label="0%"];
            L_nl_b -> L_use
    }

    // what to use a child for
    {
        // starting values
        {C_start [label="Use child what type of %?"]}

        // ending values
        {C_completed [label="completed $"; shape=box]}
        {C_tested [label="tested $"; shape=box]}

        // different depending on the type of child
        {C_req [label="REQ"]}
        {C_spc [label="SPC"]}
        {C_tst [label="TST"]}

        {C_nt [label="child type?"; shape=triangle;]}
        C_start -> C_nt;
            C_nt -> C_req;
            C_nt -> C_spc;
            C_nt -> C_tst;

        C_req -> C_completed;
        C_req -> C_tested;

        C_spc -> C_completed;

        C_tst -> C_tested;
    }
}
